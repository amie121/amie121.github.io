[{"title":"总结--前端安全","date":"2017-03-10T07:39:20.000Z","path":"2017/03/10/总结-前端安全/","text":"前端安全问题是必须防范的问题，网页都有被攻击的风险，我们必须了解其原理才能更好的采取防范措施，维护前端安全。 前端攻击形式XSS攻击跨站脚本攻击，它允许web用户将代码植入到提供给其他用户使用的页面中，在前端方面，可以简单的理解为一种JavaScript代码注入。它的核心是利用了浏览器无法区分脚本是第三方注入的，还是真的是你应用程序的一部分。 比如： 12345678//前端模板&lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;//后台数据text：&quot;&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt;&quot;;//渲染后&lt;span&gt;&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt;&lt;/span&gt; 这样网页渲染出来就会弹出warning的提示框。还有人会利用append植入恶意代码，或者是利用img标签的onerror事件触发恶意的JS代码，更有甚者，会通过JS访问到cookie中的用户敏感信息，非法获取利益。 看上面的例子，后台中的数据text往往是从用户的输入中来的，比如我们网页中很常见的表单，在填写时，如果把脚本当做内容填写进去，提交到后台，这段脚本就会被存入数据库中，当下次读取该数据渲染页面时，该脚本就会被执行，形成XSS攻击。 如何防范 XSS攻击的防范措施一般是对用户的输入进行过滤，将标签转义，使用户的输入内容不会被当成脚本来执行。 阻止非法用户通过js访问cookie中的敏感信息可以使用cookie的HttpOnly属性。 通过csp进行防范。 CSRF攻击跨站请求伪造，它就是利用用户的一些提交行为，当用户在伪造的网页上进行操作时，实际上会被操作到其他网站上。 假设我登录一个网站A，服务器会将一个session序列通过响应头的set-cookie字段发给浏览器，浏览器接受相应之后会自动将其保存起来，然后下次发请求的时候自动将cookie发送给服务器，通过此机制来记录用户的一些状态。但如果这时我在同一个浏览器打开了一个恶意网站B，我根据网页指引操作了一个点击按钮，它发起了一个请求到之前登录的网站A。这时浏览器会自动携带A网站的cookie，而服务器根据cookie判断到这是已经登录的用户，就信任这个用户的操作，为它提供服务，造成的后果非常严重。 如何防范加验证码。恶意网站是获取不到用户本次session的验证码的。因此可以通过加验证码的方法防范。缺点是对一些经常性的操作，总是要用户输入验证码，会降低用户体验。 我们也可以给所有请求加上一个token检查，token是服务器生成的一段字符串，通常会保存在页面中某个隐藏域中，相当于服务器发的“令牌”，此后客户端每次向服务端请求资源都需要带着服务端签发的Token，服务器通过验证这个token决定是否给用户返回请求的数据。 运营商劫持运营商劫持的表现为以弹出新窗口的形式在使用者界面展示广告或者直接显示某网站的内容。 我们知道，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，比如在某一环节，数据被中间代理层的劫持者所截获，在正常的数据流中插入网络数据报文，这样一来，客户端渲染页面时就会带上这些数据，植入广告。 如何防范 用https进行加密 csp httpshttp缺点： 1.通信不加密，内容可能会被窃取 2.通信的另一端可能是其他攻击者伪装的 针对以上两个安全问题，https提出的方法有：1.对通信内容进行加密 2.对通信的另一端进行身份验证 对通信内容进行加密两种加密方法：对称密钥和非对称密钥 对称密钥：A端生成一对密钥，然后将密钥发送给B端，B端拿到密钥后对内容进行加密，然后传输，A端收到加密后的内容再用密钥进行解密。缺点在A端发送密钥给B端的过程中，仍有可能被窃取，攻击者可以用窃取的密钥解密窃取的内容。 非对称密钥：B端生成一对非对称密钥，公钥负责加密，私钥负责解密。B端将公钥发给A端，A端生成对称密钥，用拿到的公钥对对称密钥中的一只进行加密，发送给B端，B端接收到以后用自己的私钥解密出这只对称密钥。接着就用这只对称密钥加密数据传送给A端。加密通信开始。 为什么不直接用公钥加密数据？因为非对称密钥加密解密的速度比对称密钥慢很多。为了同时保证安全性和效率，采取用公钥加密对称密钥，用对称密钥加密数据的方式。 对通信的另一端进行身份验证为什么要对通信的另一端进行身份验证？ 因为我们无法确保发出公钥的A端就是“真正的A端”，它也可能是假冒者发出的，那我们用它的公钥进行加密，它也可以利用自己的私钥将我们发送的加密内容解密出来，加密过程也就没有意义了。 解决方法： 通过第三方对A端的身份进行验证，这个第三方必须保证权威可靠，那我们就相信，如果第三方相信A，我们就可以相信A。这样的机构我们称为数字证书认证机构（CA）。 此时要加多一个步骤，即A端要将公钥发送给CA签名，CA用自己的私钥签名后返回给A，A把公钥发给B的同时要发送这个CA签名，B用CA公开的密钥解密签名验证签名的正确性，若正确，才相信A是“真正的A”，然后才用A发送的公钥对内容进行加密并发送给B，后续步骤相同。 优点：保证了安全性 缺点:加密解密时间长、速度慢。主要体现在： 交换密钥过程多出了1次往返 加密解密需要时间 获取CA机构签名的过程也会多一次网络往返 因此，对于一些不是特别重要的请求，就没必要用https来传输。 CSP内容安全策略，实际上是给浏览器加载资源时开具的“白名单”。 我们知道浏览器有同源策略，但是XSS就是通过虚假内容来绕过同源策略。CSP定义了Content-Security-PolicyHTTP头来允许你创建一个可信来源的白名单，使得浏览器只执行和渲染来自这些来源的资源，而不是盲目信任服务器提供的所有内容。即使攻击者可以找到漏洞来注入脚本，但是因为来源不包含在白名单里，因此将不会被执行。 比如：数据库里存了一个用户输入的信息，简单的弹窗JS1&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt; 如果没有CSP保护，页面会前面所说的XSS攻击弹出这个弹窗 如果有CSP保护，并且CSP规定来源只能是本站，那浏览器就会阻止这段脚本的执行，并在控制台输出警告信息。 CSP可以由两种方法启用： 一是通过定义HTTP响应头信息的Content-Security-Policy字段。 二是通过网页的标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 一般都采取写在http头的方式，因为这样做前端更容易布置，而不需要每个html都加上这个meta标签。 以下选项限制各类资源的加载： script-src：外部脚本 style-src：样式表 img-src：图像 media-src：媒体文件（音频和视频） font-src：字体文件 object-src：插件（比如 Flash） child-src：框架 frame-ancestors：嵌入的外部资源（比如、、和） connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等） worker-src：worker脚本 manifest-src：manifest 文件使用default-src来设置上面各个选项的默认值，还可以限制网页和其他URL发生联系 csp缺点 不能完全解决运营商劫持 因为运营商劫持能拿到页面的代码，如果在劫持过程中把代码里关于CSP的设置去掉，那CSP就不能发挥其作用。所以，CSP只能做到抵挡XSS的攻击，要防止运营商劫持还是要靠https。","tags":[{"name":"前端 安全","slug":"前端-安全","permalink":"http://yoursite.com/tags/前端-安全/"}]},{"title":"Hello","date":"2017-03-09T13:38:11.000Z","path":"2017/03/09/Hello/","text":"写给自己的话我希望自己 十分努力 十分幸运 爱我和我爱的人都幸福","tags":[]}]