[{"title":"常见内存泄露[转]","date":"2017-06-20T12:50:55.000Z","path":"2017/06/20/常见内存泄露/","text":"写在前面：原文地址一时找不到，本文大多数内容借鉴原文，用自己好理解的话表述了一遍。 关于内存泄露什么是内存泄露内存泄露值任何对象在你不再拥有或需要它之后仍然存在。 常见的导致内存泄露的几种情况： 意外的全局变量所谓意外就是违背开发者意图的行为。一般是函数中的变量不小心成为了全局（window）对象。 12345678function foo() &#123; a = &quot;this is a&quot;;&#125;// 这个函数与下面函数无异function foo() &#123; window.a = &quot;this is a&quot;;&#125; 还需要注意的是this，this意外的指向了window也会导致泄露 12345function foo() &#123; this.a = &quot;this is a&quot;;&#125;//然后全局环境下调用;此时this的指向为windowfoo(); 在严格模式下会报错，因此可以开启严格模式&#39;use strict&#39;帮助我们排查这类问题。 没有及时解除对DOM元素的引用1234567var elements = &#123; button: document.getElementById(&apos;btn&apos;), image: document.getElementById(&apos;image&apos;)&#125;;function removeButton() &#123; document.body.removeChild(document.getElementById(&apos;btn&apos;));&#125; 触发removeButton函数，虽然我们用removeChild移除了button，但是还在elements对象里保存着对button的引用，也就是说DOM元素还在内存里头。解除引用： 1234function removeButton() &#123; document.body.removeChild(document.getElementById(&apos;btn&apos;)); elements.button = null;&#125; 还有一种常见情况是在定时器里引用了DOM元素： 1234567var someCode = getCode();setInterval(function() &#123; var node = document.getElementById(&apos;node&apos;); if(node) &#123; node.innerHTML = JSON.stringify(someCode); &#125;&#125;, 1000); 此时，若把node节点从DOM中移除，由于定时器的回调中仍然保存着对someCode的引用，因此外部变量someCode不会被释放。 闭包首先先来预热一下什么是闭包，看下列一段代码 123456789var theThing = null;var replaceThing = function () &#123; var someMessage = &apos;123&apos; theThing = &#123; someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;; 在调用replaceThing之后，调用theThing.someMethod，会输出123，基本的闭包，这个不难理解。然而改一下代码 1234567891011var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var someMessage = &apos;123&apos; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), // 大概占用1MB内存 someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;; 我们先做一个假设, 如果函数中所有的私有变量, 不管someMethod用不用, 都被放进闭包的话, 那么会发生什么呢. 第一次调用replaceThing, 闭包中包含originalThing = null和someMessage = &#39;123&#39;, 我们设函数结束时, theThing的值为theThing_1. 第二次调用replaceThing, 如果我们的假设成立, originalThing = theThing_1和someMessage = &#39;123&#39;.我们设第二次调用函数结束时, theThing的值为theThing_2.注意, 此时的originalThing保存着theThing_1, theThing_1包含着和theThing_2截然不同的someMethod, theThing_1的someMethod中包含一个someMessage, 同样如果我们的假设成立, 第一次的originalThing = null应该也在. 所以, 如果我们的假设成立, 第二次调用以后, 内存中有theThing_1和theThing_2, 因为他们都是靠longStr把占用内存撑起来, 所以第二次调用以后, 内存消耗比第一次多1MB. 如果你亲自试了(使用Chrome的Profiles查看每次调用后的内存快照), 会发现我们的假设是不成立的, 浏览器很聪明, 它只会把someMethod用到的变量保存下来, 用不到的（比如originalThing）就不保存了, 这为我们节省了内存. 但如果我们这么写： 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;); &#125;; var someMessage = &apos;123&apos; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;; 打开开发者工具，会看到每秒钟1MB、1MB的涨，来分析一下这段代码是如何造成内存泄露的。 unused这个函数中，我们定义了一个引用originalThing的闭包但是没有真正调用，但是因为闭包的存在，originalThing会在词法环境中，所有定义在replaceThing里的函数都能够访问。 而someMethod这个函数中，虽然我们没有使用originalThing，但我们的确引用了它。为什么呢？因为originalThing是词法作用域的一部分（在unused函数中被放进了闭包里），someMethod会保持对originalThing的引用，导致我们每次调用都会覆盖theThing但是原来的值永远不会被清除。 与上一个例子的不同之处在于：上一个例子中originalThing并没有被someMethod引用；而这个例子中，由于unused函数引用了originalThing，someMethod会保持对originalThing的引用。 如果把unused函数去掉，或者在replaceThing函数结尾让originalThing = null，就不会泄露了。 在一个闭包中引用的任何局部变量都会被该闭包保留，只要该闭包存在就永远保留。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://yoursite.com/tags/内存泄露/"}]},{"title":"浏览器缓存","date":"2017-03-20T11:14:55.000Z","path":"2017/03/20/浏览器缓存/","text":"为什么需要浏览器缓存我们获取新资源的方式是访问服务器，将所需的资源下载到本地。然而当我们需要重新获取这些资源时，如果还是通过访问服务器下载这些资源，就会造成时间上的浪费。况且静态资源如图片、样式表、JS脚本一般不会经常改动，因此可以将这些资源缓存在本地，再次获取资源时就可以从本地下载。 浏览器缓存是如何起作用的最重要的是判断缓存是否过期，如果缓存还在有效期内并且文件没有改动过就会从本地下载，如果缓存过期或者文件已经被修改就会从服务器下载。 首次打开一个网页时，请求的文件直接从服务器下载下来，浏览器记录下响应体中的Cache-Control、Expires、Last-Modified、Etag这几个属性。并将文件缓存到本地。 再次打开这个页面，缓存机制开始起作用： 首先判断该文件是否有缓存，如果没有则从服务器下载；如果有则判断缓存是否过期。 在Cache-Control中有个max-age值，该值指示浏览器可以接收生存期不大于指定时间（以秒为单位）的响应，它与Expires都是用来记录有效期的，如果没有过期，浏览器就直接从缓存中读取。 如果已经过了期限，浏览器会发请求到服务器，请求头包含Last-Modified-Since、If-None-Match，分别为浏览器记录下的Last-Modified、Etag。服务器端通过这两个值来判断文件是否被修改过，如果没有修改过，返回一个304的状态码给浏览器，让浏览器继续从缓存中读取，如果文件已经被修改过了，则把文件发送给浏览器，浏览器更新Cache-Control、Expires、Last-Modified、Etag的值。 Expires和max-age： Expires记录的是绝对时间，max-age记录的是相对时间，max-age的优先级更高，Cache-control的max-age和max-stale会覆盖Expires header，因为使用Expires存在服务器和浏览器时间不一致的问题。 Last-Modified-Since和If-None-Match： If-None-Match比Last-Modified-Since的优先级高， 1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度 2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 不会被缓存的几种情况 POST请求 https请求 http响应头设置的Cache-Control:no-Cache,Etag和Last-Modified的值为空 更新静态资源如果服务器上改动一个JS脚本文件，但是如果浏览器在判断Expires和Cache-Control中的max-age这两个值的时候仍满足缓存条件（毕竟静态文件不会经常改动，设置比较长的缓存期也是很常见的）的时候，这时候连请求都不会发，怎么更新这个文件呢？ 解决方案：通过更新页面中引用的资源路径，加载新资源，最常见的做法就是给文件加一个版本后缀，例如：1&lt;script src=&quot;test.js?v=$&#123;version&#125;&quot;/&gt; 目的是让浏览器把该文件当做是一个新的文件来加载 如果页面结构，CSS样式和JS脚本都需要改动，这时候怎么把改动的东西发布到服务器上呢？ 无论先发布哪一个文件，中间的时间间隔都可能会造成页面样式错误或js无法交互，所以很多公司都会在趁用户访问量比较低，比如凌晨的时候发布新的资源，这样可以减少用户访问页面出错的概率。但这不是最好的解法方案，FIS提出了一种更好的解决方案： 先发布CSS样式和JS脚本，但是这些CSS样式和JS脚本会重新命名，避免覆盖服务器上旧的CSS和JS，这时候旧的页面仍然是使用旧的CSS和JS。然后再修改页面中的引用资源路径，修改成重新命名的资源路径，这样子一旦页面发布上去了，就可以直接访问到之前已经发布到服务器上的资源，而不会出现页面出错的情况。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"同源政策及跨域解决方案","date":"2017-03-12T12:38:55.000Z","path":"2017/03/12/同源政策及跨域解决方案/","text":"同源政策什么是同源政策同源策略的同源是指：协议相同（http://）、域名相同（www.example.com）、端口相同（:80）。只有同源的网站才允许相互通信，而无法访问其他域的资源。 同源政策的目的同源政策的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。假设我们登录了一个可信网站A，浏览器记录下了cookie，如果没有同源策略，当我们再去浏览其他的网站，其他网站就可以读取A网站的cookie，此时我们的信息就会泄露。而我们知道，cookie一般是用来保存登录状态的，如果我们没有退出登录就去浏览其他网站，其他网站就可以冒充用户进行操作。可见，同源政策是非常有必要的。 注意： 浏览器的同源策略不是指浏览器不能发送请求到其他源的服务器上，而是其他源的服务器相应回来的时候浏览器会拒绝这个相应。 安全性和方便性是成反比的，同源政策提升了web的安全性，但牺牲了web扩展的灵活性。想把所有资源都布置在一台服务器上，对于大一点的网站基本是不可能的。因此现代浏览器在保证安全性的同时，也选择性的为同源政策开了“后门”，允许像img、script、style等标签跨域引用资源。当然这样的做法牺牲了一些安全性，例如img标签常常作为csrf攻击的漏洞之一，此时要做其他的安全防范。 那如何实现不同源的通信呢？ 跨域解决方案JSONPJSONP是利用script标签可以跨域引用资源的原理来实现的。假设A（www.a.com）中需要从源B（www.b.com）获得数据，则在A中引入一段script脚本&lt;script src = &quot;www.b.com/data.js?callback=foo&quot;&gt;&lt;/script&gt;，用于向B发出请求。B会根据请求的查询字符串中的callback属性的值生成一段返回数据的脚本foo(data),这时A就会将这段脚本下载下来并执行foo(data)。可是foo函数我们还没定义，因此还需要在对B发送请求之前定义好这个foo全局函数。 示例代码：1234567891011121314&lt;!-- a.com --&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script&gt; function foo(data)&#123; var data = JSON.parse(data); // to do ... console.log(data.name,data.type); &#125; &lt;/script&gt; &lt;script src = &quot;www.b.com/data.js?callback=foo&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789// b.com 伪代码router.on(&quot;/data.js&quot;,function(req,res)&#123; var urlObj = http.parse(req); var funName = urlObj[&quot;callback&quot;]; var data = &quot;&#123;name:bb,type:1&#125;&quot; var content = funcName + &quot;(&quot; + data + &quot;);&quot;; res.end(content);&#125;); 优势：简单适用，支持老式浏览器，可以向不支持CORS的网站请求数据 缺点：只支持GET请求 CORS实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多一次附加的请求(请求方法为PUT,DELETE时)，但用户不会有感觉。 假设A（www.a.com）中需要从源B（www.b.com）获得数据，可以在B的响应头中设置Access-Control-Allow-Origin: www.a.com，这样一来，浏览器就知道A是B服务器允许跨域请求的网站，浏览器就会接受这个响应，然后执行回调，正常工作。 服务器代理服务器代理是指在浏览器和不同源的服务器之间设置一个代理服务器，浏览器发出的请求会先发送到这个代理服务器，再由这个代理服务器发送到异源服务器。返回的数据依然是先经过代理服务器再发回给浏览器，由于代理服务器和浏览器是同源的，就不会同源政策的限制。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"同源政策","slug":"同源政策","permalink":"http://yoursite.com/tags/同源政策/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"前端安全","date":"2017-03-10T07:39:20.000Z","path":"2017/03/10/总结-前端安全/","text":"前端安全问题是必须防范的问题，网页都有被攻击的风险，我们必须了解其原理才能更好的采取防范措施，维护前端安全。 前端攻击形式XSS攻击跨站脚本攻击，它允许web用户将代码植入到提供给其他用户使用的页面中，在前端方面，可以简单的理解为一种JavaScript代码注入。它的核心是利用了浏览器无法区分脚本是第三方注入的，还是真的是你应用程序的一部分。 比如： 12345678//前端模板&lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;//后台数据text：&quot;&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt;&quot;;//渲染后&lt;span&gt;&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt;&lt;/span&gt; 这样网页渲染出来就会弹出warning的提示框。还有人会利用append植入恶意代码，或者是利用img标签的onerror事件触发恶意的JS代码，更有甚者，会通过JS访问到cookie中的用户敏感信息，非法获取利益。 看上面的例子，后台中的数据text往往是从用户的输入中来的，比如我们网页中很常见的表单，在填写时，如果把脚本当做内容填写进去，提交到后台，这段脚本就会被存入数据库中，当下次读取该数据渲染页面时，该脚本就会被执行，形成XSS攻击。 如何防范 XSS攻击的防范措施一般是对用户的输入进行过滤，将标签转义，使用户的输入内容不会被当成脚本来执行。 阻止非法用户通过js访问cookie中的敏感信息可以使用cookie的HttpOnly属性。 通过csp进行防范。 CSRF攻击跨站请求伪造，它就是利用用户的一些提交行为，当用户在伪造的网页上进行操作时，实际上会被操作到其他网站上。 假设我登录一个网站A，服务器会将一个session序列通过响应头的set-cookie字段发给浏览器，浏览器接受相应之后会自动将其保存起来，然后下次发请求的时候自动将cookie发送给服务器，通过此机制来记录用户的一些状态。但如果这时我在同一个浏览器打开了一个恶意网站B，我根据网页指引操作了一个点击按钮，它发起了一个请求到之前登录的网站A。这时浏览器会自动携带A网站的cookie，而服务器根据cookie判断到这是已经登录的用户，就信任这个用户的操作，为它提供服务，造成的后果非常严重。 如何防范加验证码。恶意网站是获取不到用户本次session的验证码的。因此可以通过加验证码的方法防范。缺点是对一些经常性的操作，总是要用户输入验证码，会降低用户体验。 我们也可以给所有请求加上一个token检查，token是服务器生成的一段字符串，通常会保存在页面中某个隐藏域中，相当于服务器发的“令牌”，此后客户端每次向服务端请求资源都需要带着服务端签发的Token，服务器通过验证这个token决定是否给用户返回请求的数据。 运营商劫持运营商劫持的表现为以弹出新窗口的形式在使用者界面展示广告或者直接显示某网站的内容。 我们知道，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，比如在某一环节，数据被中间代理层的劫持者所截获，在正常的数据流中插入网络数据报文，这样一来，客户端渲染页面时就会带上这些数据，植入广告。 如何防范 用https进行加密 csp httpshttp缺点： 1.通信不加密，内容可能会被窃取 2.通信的另一端可能是其他攻击者伪装的 针对以上两个安全问题，https提出的方法有：1.对通信内容进行加密 2.对通信的另一端进行身份验证 对通信内容进行加密两种加密方法：对称密钥和非对称密钥 对称密钥：A端生成一对密钥，然后将密钥发送给B端，B端拿到密钥后对内容进行加密，然后传输，A端收到加密后的内容再用密钥进行解密。缺点在A端发送密钥给B端的过程中，仍有可能被窃取，攻击者可以用窃取的密钥解密窃取的内容。 非对称密钥：B端生成一对非对称密钥，公钥负责加密，私钥负责解密。B端将公钥发给A端，A端生成对称密钥，用拿到的公钥对对称密钥中的一只进行加密，发送给B端，B端接收到以后用自己的私钥解密出这只对称密钥。接着就用这只对称密钥加密数据传送给A端。加密通信开始。 为什么不直接用公钥加密数据？因为非对称密钥加密解密的速度比对称密钥慢很多。为了同时保证安全性和效率，采取用公钥加密对称密钥，用对称密钥加密数据的方式。 对通信的另一端进行身份验证为什么要对通信的另一端进行身份验证？ 因为我们无法确保发出公钥的A端就是“真正的A端”，它也可能是假冒者发出的，那我们用它的公钥进行加密，它也可以利用自己的私钥将我们发送的加密内容解密出来，加密过程也就没有意义了。 解决方法： 通过第三方对A端的身份进行验证，这个第三方必须保证权威可靠，那我们就相信，如果第三方相信A，我们就可以相信A。这样的机构我们称为数字证书认证机构（CA）。 此时要加多一个步骤，即A端要将公钥发送给CA签名，CA用自己的私钥签名后返回给A，A把公钥发给B的同时要发送这个CA签名，B用CA公开的密钥解密签名验证签名的正确性，若正确，才相信A是“真正的A”，然后才用A发送的公钥对内容进行加密并发送给B，后续步骤相同。 优点：保证了安全性 缺点:加密解密时间长、速度慢。主要体现在： 交换密钥过程多出了1次往返 加密解密需要时间 获取CA机构签名的过程也会多一次网络往返 因此，对于一些不是特别重要的请求，就没必要用https来传输。 CSP内容安全策略，实际上是给浏览器加载资源时开具的“白名单”。 我们知道浏览器有同源策略，但是XSS就是通过虚假内容来绕过同源策略。CSP定义了Content-Security-PolicyHTTP头来允许你创建一个可信来源的白名单，使得浏览器只执行和渲染来自这些来源的资源，而不是盲目信任服务器提供的所有内容。即使攻击者可以找到漏洞来注入脚本，但是因为来源不包含在白名单里，因此将不会被执行。 比如：数据库里存了一个用户输入的信息，简单的弹窗JS1&lt;script&gt;alert(&apos;warning&apos;)&lt;/script&gt; 如果没有CSP保护，页面会前面所说的XSS攻击弹出这个弹窗 如果有CSP保护，并且CSP规定来源只能是本站，那浏览器就会阻止这段脚本的执行，并在控制台输出警告信息。 CSP可以由两种方法启用： 一是通过定义HTTP响应头信息的Content-Security-Policy字段。 二是通过网页的标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 一般都采取写在http头的方式，因为这样做前端更容易布置，而不需要每个html都加上这个meta标签。 以下选项限制各类资源的加载： script-src：外部脚本 style-src：样式表 img-src：图像 media-src：媒体文件（音频和视频） font-src：字体文件 object-src：插件（比如 Flash） child-src：框架 frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;） connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等） worker-src：worker脚本 manifest-src：manifest 文件使用default-src来设置上面各个选项的默认值，还可以限制网页和其他URL发生联系 csp缺点 不能完全解决运营商劫持 因为运营商劫持能拿到页面的代码，如果在劫持过程中把代码里关于CSP的设置去掉，那CSP就不能发挥其作用。所以，CSP只能做到抵挡XSS的攻击，要防止运营商劫持还是要靠https。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"Hello","date":"2017-03-09T13:38:11.000Z","path":"2017/03/09/Hello/","text":"写给自己的话我希望自己 十分努力 十分幸运 爱我和我爱的人都幸福","tags":[]}]